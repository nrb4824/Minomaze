<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | My project</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <link rel="stylesheet" href="MoveFolder/styles.css"> <!-- Linking the external CSS file -->
</head>
<body>

    <header>
        <h1>Minomaze</h1>
    </header>
    <div style="padding:20px; margin-bottom:28%;">
        <h2 class="descriptor">Description:</h2>
        <p>
            This project is trying to educationally gamify Visibility Graphs working with common shortest path algorithms.
            We take the classic story of the Minotaur in the Knossos labryinth and use that as the basis of a simple video game.
            The maze is made up of polygons that are pre-made made by the player.
            The player can then view the path made by the visibility graph and shortest path algorithms.
        </p>
    </div>

    <div id="unity-container" class="unity-desktop" >
        <canvas id="unity-canvas" width=960 height=600 tabindex="-1"></canvas>
        <div id="unity-loading-bar">
            <div id="unity-logo"></div>
            <div id="unity-progress-bar-empty">
                <div id="unity-progress-bar-full"></div>
            </div>
        </div>
        <div id="unity-warning"> </div>
        <div id="unity-footer">
            <div id="unity-fullscreen-button"></div>
            <div id="unity-build-title">Minomaze</div>
        </div>
    </div>


    <div style="padding:20px; margin-bottom:5%;">
        <h2 class="descriptor">How It Works:</h2>
        <p>
            A visibility graph works by taking two start points and the verticies of all polygons in the maze.
            Then for each vertice of each polygon, determine which other vertices are within a line of sight (not through another polygon),
            and create an edge between that vertex and the other one. The only modification needed for this implementation is that we must allow edges to be formed
            on the edges of polygons for the shortest path algorithm. This graph is later used with the A* shortest path algorithms to determine the shortest path from the player to the Minotaur.
        </p>

        <h2 class="descriptor">Controls:</h2>
        <p>
            The green dot is you, and the yellow dot is the Minotaur. When you start there is a straight path between you and the Minotaur. To add obstacles, click on the red draw button.
            The button will turn green, this means you are drawing. Click on at least 3 points on the screen, then click the draw button again to finish the polygon. Your shape will be drawn and a visibility graph 
            and shortest path will be calculated and displayed. To draw more polygons, repeat the steps using the draw button. When the draw button is red your clicks will not draw polygons and when it is green they will.
        </p>
        <div class="grid-container">
            <img src="MoveFolder/ShowDraw.jpg" alt="show draw" class="grid-item" style="width:100%; height:auto;" />
            <div class="grid-item">
                <img src="MoveFolder/RedDraw.jpg" alt="red draw" />
                <img src="MoveFolder/GreenDraw.jpg" alt="green draw" />
            </div>
            <img src="MoveFolder/DrawFinished.jpg" alt="draw finished" class="grid-item" style="width:100%; height:auto;" />
        </div>
        

        <h2 class="descriptor">Limitations</h2>
        <p>
            In the current implementation, the player can only draw polygons that don't cross over itself. The draw tool is not advanced enough to disallow this, and it will break the visibility graph and shortest path algorithms.
            This might seem obvious as if a polygon crosses over itself it isn't really a singular polygon.
        </p>
        <img src="MoveFolder/DontPolygon.jpg" alt="don't polygon" />

        <h2 class="descriptor">Complexity Analysis</h2>

        <h2 class="descriptor">Other Projects</h2>

    </div>
   

    <footer>
        <p>Created by Nathan Borkholder & Charles Hacker &copy; 2024</p>
    </footer>


    <script>

        var container = document.querySelector("#unity-container");
        var canvas = document.querySelector("#unity-canvas");
        var loadingBar = document.querySelector("#unity-loading-bar");
        var progressBarFull = document.querySelector("#unity-progress-bar-full");
        var fullscreenButton = document.querySelector("#unity-fullscreen-button");
        var warningBanner = document.querySelector("#unity-warning");

        // Shows a temporary message banner/ribbon for a few seconds, or
        // a permanent error message on top of the canvas if type=='error'.
        // If type=='warning', a yellow highlight color is used.
        // Modify or remove this function to customize the visually presented
        // way that non-critical warnings and error messages are presented to the
        // user.
        function unityShowBanner(msg, type) {
            function updateBannerVisibility() {
                warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
            }
            var div = document.createElement('div');
            div.innerHTML = msg;
            warningBanner.appendChild(div);
            if (type == 'error') div.style = 'background: red; padding: 10px;';
            else {
                if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
                setTimeout(function () {
                    warningBanner.removeChild(div);
                    updateBannerVisibility();
                }, 5000);
            }
            updateBannerVisibility();
        }

        var buildUrl = "Build";
        var loaderUrl = buildUrl + "/docs.loader.js";
        var config = {
            dataUrl: buildUrl + "/docs.data",
            frameworkUrl: buildUrl + "/docs.framework.js",
            codeUrl: buildUrl + "/docs.wasm",
            streamingAssetsUrl: "StreamingAssets",
            companyName: "DefaultCompany",
            productName: "My project",
            productVersion: "1.0",
            showBanner: unityShowBanner,
        };

        // By default, Unity keeps WebGL canvas render target size matched with
        // the DOM size of the canvas element (scaled by window.devicePixelRatio)
        // Set this to false if you want to decouple this synchronization from
        // happening inside the engine, and you would instead like to size up
        // the canvas DOM size and WebGL render target sizes yourself.
        // config.matchWebGLToCanvasSize = false;

        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            // Mobile device style: fill the whole browser client area with the game canvas:

            var meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
            document.getElementsByTagName('head')[0].appendChild(meta);
            container.className = "unity-mobile";
            canvas.className = "unity-mobile";

            // To lower canvas resolution on mobile devices to gain some
            // performance, uncomment the following line:
            // config.devicePixelRatio = 1;


        } else {
            // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:

            canvas.style.width = "960px";
            canvas.style.height = "600px";
        }

        loadingBar.style.display = "block";

        var script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
            createUnityInstance(canvas, config, (progress) => {
                progressBarFull.style.width = 100 * progress + "%";
            }).then((unityInstance) => {
                loadingBar.style.display = "none";
                fullscreenButton.onclick = () => {
                    unityInstance.SetFullscreen(1);
                };
            }).catch((message) => {
                alert(message);
            });
        };

        document.body.appendChild(script);

    </script>
</body>
</html>
